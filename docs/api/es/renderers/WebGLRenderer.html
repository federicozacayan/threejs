<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<base href="../../../" />
		<script src="page.js"></script>
		<link type="text/css" rel="stylesheet" href="page.css" />
	</head>
	<body>
		<h1>[name]</h1>

		<p class="desc">
			El renderizador WebGL muestra tus escenas bellamente diseñadas usando
			[link:https://en.wikipedia.org/wiki/WebGL WebGL].
		</p>

		<h2>Constructor</h2>

		<h3>[name]( [param:Object parameters] )</h3>
		<p>
		[page:Object parameters] - (opcional) objeto con propiedades que definen el comportamiento del renderizador.
		El constructor tampoco acepta ningún parámetro. En todos los casos, asumirá valores predeterminados sensatos cuando falten parámetros. Los siguientes son parámetros válidos:<br /><br />

		[page:DOMElement canvas] - Un [link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas canvas]
		donde el renderizador dibuja su salida.
		Esto corresponde a la propiedad [page:WebGLRenderer.domElement domElement] que se detalla a continuación. 
		Si no se pasa aquí, se creará un nuevo elemento de lienzo.<br />


		[page:WebGLRenderingContext context] - Esto se puede usar para adjuntar el representador a un
	    [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext RenderingContext] existente.
	  	El valor predeterminado es nulo.<br />

		[page:String precision] - Precisión del Shader. Puede ser `"highp"`, `"mediump"` or `"lowp"`.
		El valor predeterminado es "highp" si el dispositivo lo admite.<br />

		[page:Boolean alpha] - controla el valor alfa claro predeterminado. Cuando se establece en `true`, el valor es `0`. De lo contrario, es `1`. El valor predeterminado es `false`.<br />

		[page:Boolean premultipliedAlpha] - si el renderizador asumirá que los colores tienen
		[link:https://en.wikipedia.org/wiki/Glossary_of_computer_graphics#Premultiplied_alpha premultiplied alpha].
		El valor predeterminado es  `true`.<br />

		[page:Boolean antialias] -si se debe realizar antialiasing. El valor predeterminado es `false`.<br />

		[page:Boolean stencil] - si el búfer de dibujo tiene un
		[link:https://en.wikipedia.org/wiki/Stencil_buffer stencil buffer] de al menos 8 bits.
		El valor predeterminado es `true`.<br />

		[page:Boolean preserveDrawingBuffer] - si conservar los búferes hasta que se borren manualmente
		o se sobreescriben. El valor predeterminado es `false`.<br />

		[page:String powerPreference] - Proporciona una pista al agente de usuario que indica qué configuración
		de GPU es adecuado para este contexto WebGL. Puede ser `"high-performance"`, `"low-power"` or `"default"`. El valor predeterminado es `"default"`.
		Consultar [link:https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.2 WebGL spec] para más detalles.<br />

		[page:Boolean failIfMajorPerformanceCaveat] - si se detecta un error en la creación del renderizador en caso de bajo rendimiento. El valor predeterminado es `false`.
		Consultar [link:https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.2 WebGL spec] para más detalles.<br />

		[page:Boolean depth] - si el búfer de dibujo tiene un
		[link:https://en.wikipedia.org/wiki/Z-buffering depth buffer] de al menos 16 bits.
		El valor predeterminado es `true`.<br />

		[page:Boolean logarithmicDepthBuffer] - si se utiliza un búfer de profundidad logarítmica. Puede
		será necesario usar esto si se trata de grandes diferencias de escala en una sola escena. Tenga en cuenta que esta configuración
		usa gl_FragDepth si está disponible, lo que deshabilita el [link:https://www.khronos.org/opengl/wiki/Early_Fragment_Test Early Fragment Test]
		optimization and can cause a decrease in performance.
		El valor predeterminado es `false`. Ver el ejemplo [example:webgl_camera_logarithmicdepthbuffer camera / logarithmicdepthbuffer].
		</p>

		<h2>Propiedades</h2>

		<h3>[property:Boolean autoClear]</h3>
		<p>Define si el renderizador debe borrar automáticamente su salida antes de renderizar frame.</p>


		<h3>[property:Boolean autoClearColor]</h3>
		<p>
			Si [page:.autoClear autoClear] es verdadero, define si el renderizador debe borrar el búfer de color.
			El valor predeterminado es`true`.
		</p>


		<h3>[property:Boolean autoClearDepth]</h3>
		<p>
			Si [page:.autoClear autoClear] es verdadero, define si el renderizador debe borrar el búfer de profundidad.
			El valor predeterminado es `true`.
		</p>


		<h3>[property:Boolean autoClearStencil]</h3>
		<p>
			Si [page:.autoClear autoClear] es verdadero, define si el renderizador debe borrar el búfer de la plantilla.
			El valor predeterminado es `true`.
		</p>

		<h3>[property:Object debug]</h3>
		<p>
		- [page:Boolean checkShaderErrors]:
		  If it is true, defines whether material shader programs are checked
			for errors during compilation and linkage process. It may be useful to disable this check in production for performance gain.
			It is strongly recommended to keep these checks enabled during development.
			If the shader does not compile and link - it will not work and associated material will not render.
			El valor predeterminado es `true`.
		</p>

		<h3>[property:Object capabilities]</h3>
		<p>
			Un objeto que contiene detalles sobre las capacidades del actual [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext RenderingContext].<br />

		- [page:Boolean floatFragmentTextures]: si el contexto admite la extensión [link:https://developer.mozilla.org/en-US/docs/Web/API/OES_texture_float OES_texture_float]<br />
		- [page:Boolean floatVertexTextures]: `true` si [page:Boolean floatFragmentTextures] y [page:Boolean vertexTextures] son verdaderos.<br />
		- [page:Method getMaxAnisotropy](): Devuelve la anisotropía máxima disponible.<br />
		- [page:Method getMaxPrecision](): Devuelve la máxima precisión disponible para vertex y fragment shaders. <br />
		- [page:Boolean isWebGL2]: `true` si el contexto en uso es un objeto WebGL2RenderingContext.<br />
		- [page:Boolean logarithmicDepthBuffer]: `true` si el  [page:parameter logarithmicDepthBuffer] se estableció en verdadero en el constructor y el contexto admite la extensión [link:https://developer.mozilla.org/en-US/docs/Web/API/EXT_frag_depth EXT_frag_depth].<br />
		- [page:Integer maxAttributes]: El valor de `gl.MAX_VERTEX_ATTRIBS`.<br />
		- [page:Integer maxCubemapSize]: El valor de `gl.MAX_CUBE_MAP_TEXTURE_SIZE`.
		Máximo alto * ancho de texturas de mapa de cubo que puede usar un shader.<br />
		- [page:Integer maxFragmentUniforms]: El valor de `gl.MAX_FRAGMENT_UNIFORM_VECTORS`.
		El número de uniforms que puede usar un fragment shader.<br />
		- [page:Integer maxSamples]: El valor de `gl.MAX_SAMPLES`.
		Número máximo de samples en el contexto del Multisample anti-aliasing (MSAA).<br />
		- [page:Integer maxTextureSize]: El valor de `gl.MAX_TEXTURE_SIZE`.
		Máximo alto * ancho de una textura que usa un shader.<br />
		- [page:Integer maxTextures]: El valor de `gl.MAX_TEXTURE_IMAGE_UNITS`.
		El número máximo de texturas que puede usar un shader.<br />
		- [page:Integer maxVaryings]: El valor de `gl.MAX_VARYING_VECTORS`.
		La cantidad de vectores variables que pueden usar los shaders.<br />
		- [page:Integer maxVertexTextures]: El valor de `gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS`.
		La cantidad de texturas que se pueden usar en un vertex shader.<br />
		- [page:Integer maxVertexUniforms]: El valor de `gl.MAX_VERTEX_UNIFORM_VECTORS`.
		El número máximo de uniformes que se pueden usar en un vertex shader.<br />
		- [page:String precision]: TLa precisión del shader que está utilizando actualmente el renderer.<br />
		- [page:Boolean vertexTextures]: `true` si [property:Integer maxVertexTextures] es mayor a 0 (i.e. se pueden usar vertex textures).<br />
		</p>

		<h3>[property:Array clippingPlanes]</h3>
		<p>
			Planos de recorte definidos por el usuario especificados como THREE.Plane objects en el espacio global.
			Estos planos se aplican globalmente. Los puntos en el espacio cuyo `producto escalar` con el plano es negativo se cortan.
		 El valor predeterminado es [].
		</p>

		<h3>[property:DOMElement domElement]</h3>
		<p>
			Un [link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas canvas] donde el renderer dibuja su salida..<br />
			Esto lo crea automáticamente el renderizador en el constructor (si aún no se ha proporcionado); solo necesita agregarlo a su página así:<br />
		<code>
			document.body.appendChild( renderer.domElement );
		</code>
	  </p>

		<h3>[property:Object extensions]</h3>
		<p>
		- [page:Object get]( [param:String extensionName] ):
		Se utiliza para verificar si se admiten varias extensiones y devuelve un objeto con detalles de la extensión, si está disponible.
		Este método puede verificar las siguientes extensiones:<br />

		<ul>
			<li>`WEBGL_depth_texture`</li>
			<li>`EXT_texture_filter_anisotropic`</li>
			<li>`WEBGL_compressed_texture_s3tc`</li>
			<li>`WEBGL_compressed_texture_pvrtc`</li>
			<li>`WEBGL_compressed_texture_etc1`</li>
		</ul>
		</p>

		<h3>[property:number outputEncoding]</h3>
		<p>Define la codificación de salida del renderizador. El valor predeterminado es [page:Textures THREE.LinearEncoding].</p>
		<p>Si se ha establecido un destino de renderizado usando [page:WebGLRenderer.setRenderTarget .setRenderTarget] en su lugar se usará renderTarget.texture.encoding.</p>
		<p>Consultar [page:Textures texture constants] para más detalles de otros formatos.</p>

		<h3>[property:Object info]</h3>
		<p>Un objeto con una serie de información estadística sobre la memoria de la tarjeta gráfica y el proceso de renderizado. Útil para la depuración o simplemente por curiosidad. El objeto contiene los siguientes campos:</p>
		<p>
		<ul>
			<li>memory:
				<ul>
					<li>geometries</li>
					<li>textures</li>
				</ul>
			</li>
			<li>render:
				<ul>
					<li>calls</li>
					<li>triangles</li>
					<li>points</li>
					<li>lines</li>
					<li>frame</li>
				</ul>
			</li>
			<li>programs
			</li>
		</ul>
		</p>
		<p>De manera predeterminada, estos datos se restablecen en cada llamada de renderizado, pero cuando se tienen múltiples pases de renderizado por cuadro (por ejemplo, cuando se usa el procesamiento posterior), se puede preferir restablecer con un patrón personalizado.
			Primero, establezca `autoReset` en `false`.
		<code>
		renderer.info.autoReset = false;
		</code>
		Llamar `reset()` cada vez que se termine de renderizar cada frame.
		<code>
		renderer.info.reset();
		</code>
		</p>

		<h3>[property:Boolean localClippingEnabled]</h3>
		<p>Define si el renderizador respeta los planos de recorte a nivel de objeto. El valor predeterminado es`false`.</p>

		<h3>[property:Boolean physicallyCorrectLights]</h3>
		<p>
			Ya sea para usar el modo de iluminación físicamente correcto. El valor predeterminado es `false`.
		Ver el ejemplo [example:webgl_lights_physical lights / physical].
		</p>

		<h3>[property:Object properties]</h3>
		<p>
			Utilizado internamente por el renderizador para realizar un seguimiento de varias propiedades de subobjetos.
		</p>

		<h3>[property:WebGLRenderLists renderLists]</h3>
		<p>
			Se usa internamente para manejar el orden de la representación de objetos de escena.
		</p>

		<h3>[property:WebGLShadowMap shadowMap]</h3>
		<p>
		Contiene la referencia al mapa de sombras, si se usa.<br />
		- [page:Boolean enabled]:
		Si está configurado,  usa shadow maps en la escena. El valor predeterminado es `false`.<br />
		- [page:Boolean autoUpdate]:
		Habilita las actualizaciones automáticas de las sombras en la escena. El valor predeterminado es `true`.<br />
		Si no necesita iluminación / sombras dinámicas, puede establecer esto en "falso" cuando se crea una instancia del renderizador.<br />
		- [page:Boolean needsUpdate]:
			Cuando se establece en  `true`, shadow maps en la escena se actualizarán en la próxima `render` call. El valor predeterminado es `false`.<br />
			Si ha deshabilitado las actualizaciones automáticas de los(`shadowMap.autoUpdate = false`), tendrá que configurar esto en `true` y luego haga una render call para actualizar las sombras en su escena.<br />
		- [page:Integer type]:
		Define el tipo de mapa de sombras (sin filtrar, porcentaje de filtrado más cercano, porcentaje de filtrado más cercano con filtrado bilineal en el sombreador). Las opciones son:
			<ul>
				<li>THREE.BasicShadowMap</li>
				<li>THREE.PCFShadowMap (default)</li>
				<li>THREE.PCFSoftShadowMap</li>
				<li>THREE.VSMShadowMap</li>
			</ul>
			Consulte Constantes del renderizador ([page:Renderer Renderer constants]) para obtener más información.<br />
		</p>

		<h3>[property:Boolean sortObjects]</h3>
		<p>
			Define si el renderizador debe ordenar los objetos. El valor predeterminado es `true`.<br /><br />

			Nota: El ordenamiento se utiliza para intentar renderizar correctamente los objetos que tienen cierto grado de transparencia. Por definición, es posible que el ordenamiento de objetos no funcione en todos los casos. Dependiendo de las necesidades de la aplicación, puede ser necesario desactivar el ordenamiento y usar otros métodos para manejar el renderizado de transparencia. 
			Por ejemplo, determinando manualmente el orden de renderizado de cada objeto.
		</p>

		<h3>[property:Object state]</h3>
		<p>
			Contiene funciones para configurar varias propiedades del estado de el [page:WebGLRenderer.context].
		</p>

		<h3>[property:Constant toneMapping]</h3>
		<p>
		El valor predeterminado es [page:Renderer NoToneMapping]. Ver las [page:Renderer Renderer constants] para conocer otras opciones.
		</p>

		<h3>[property:Number toneMappingExposure]</h3>
		<p>
			Nivel de exposición del mapeo de tonos. El valor predeterminado es `1`.
		</p>

		<h3>[property:WebXRManager xr]</h3>
		<p>
			Proporciona acceso a la [page:WebXRManager interface] relacionada con WebXR del renderer.
		</p>

		<h2>Métodos</h2>

		<h3>[method:undefined clear]( [param:Boolean color], [param:Boolean depth], [param:Boolean stencil] )</h3>
		<p>
			Le dice al renderizador que borre su(s) búfer(es) de dibujo de color, profundidad o plantilla. Este método inicializa el búfer de color al valor de color claro actual.
			Los argumentos por defecto son `true`.
		</p>

		<h3>[method:undefined clearColor]( )</h3>
		<p>Borrar el búfer de color. Equivale a llamar [page:WebGLRenderer.clear .clear]( true, false, false ).</p>

		<h3>[method:undefined clearDepth]( )</h3>
		<p>Borrar el búfer de profundidad. Equivale a llamar [page:WebGLRenderer.clear .clear]( false, true, false ).</p>

		<h3>[method:undefined clearStencil]( )</h3>
		<p>Borrar los stencil buffers. Equivale a llamar [page:WebGLRenderer.clear .clear]( false, false, true ).</p>

		<h3>[method:undefined compile]( [param:Object3D scene], [param:Camera camera] )</h3>
		<p>Recopila todos los materiales de la escena con la cámara. Esto es útil para precompilar shaders antes del primer renderizado.</p>

		<h3>[method:undefined copyFramebufferToTexture]( [param:Vector2 position], [param:FramebufferTexture texture], [param:Number level] )</h3>
		<p>Copia píxeles del WebGLFramebuffer actual en una textura 2D. Habilita el acceso a [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/copyTexImage2D WebGLRenderingContext.copyTexImage2D].</p>

		<h3>[method:undefined copyTextureToTexture]( [param:Vector2 position], [param:Texture srcTexture], [param:Texture dstTexture], [param:Number level] )</h3>
		<p>Copia todos los píxeles de una textura a una textura existente a partir de la posición dada. Habilita el acceso a [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texSubImage2D WebGLRenderingContext.texSubImage2D].</p>

		<h3>[method:undefined copyTextureToTexture3D]( [param:Box3 sourceBox], [param:Vector3 position], [param:Texture srcTexture], [param:Texture dstTexture], [param:Number level] )</h3>
		<p>Copia los píxeles de una textura en los límites '[page:Box3 sourceBox]' in the destination textureen la textura de destino a partir de la posición dada. Habilita el acceso a [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/texSubImage3D WebGL2RenderingContext.texSubImage3D].</p>

		<h3>[method:undefined dispose]( )</h3>
		<p>
			Libera los recursos relacionados con GPU asignados por esta instancia. Llame a este método cada vez que esta instancia ya no se use en su aplicación.
		</p>

		<h3>[method:undefined forceContextLoss]()</h3>
		<p>
			Simula la pérdida del contexto. Esto requiere compatibilidad con las extensiones [link:https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_lose_context WEBGL_lose_context].
		</p>

		<h3>[method:undefined forceContextRestore]( )</h3>
		<p>
			Simula la restauración del contexto WebGL. Esto requiere compatibilidad con las extensiones [link:https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_lose_context WEBGL_lose_context].
		</p>

		<h3>[method:Float getClearAlpha]()</h3>
		<p>Devuelve un [page:Float float] con el color transparente actual. Va de 0 a 1.</p>

		<h3>[method:Color getClearColor]( [param:Color target] )</h3>
		<p>Devuelve una instancia de [page:Color THREE.Color] con el color transparente actual.</p>

		<h3>[method:WebGL2RenderingContext getContext]()</h3>
		<p>Devuelve el contexto WebGL actual.</p>

		<h3>[method:WebGLContextAttributes getContextAttributes]()</h3>
		<p>Devuelve un objeto que describe los atributos establecidos en el contexto WebGL cuando se creó.</p>

		<h3>[method:Integer getActiveCubeFace]()</h3>
		<p>RDevuelve la cara del cubo activo actual.</p>

		<h3>[method:Integer getActiveMipmapLevel]()</h3>
		<p>Devuelve el nivel de mipmap activo actual.</p>

		<h3>[method:RenderTarget getRenderTarget]()</h3>
		<p>Devuelve el [page:RenderTarget RenderTarget] si lo hay; devuelve `null` en caso contrario..</p>

		<h3>[method:Vector4 getCurrentViewport]( [param:Vector4 target] )</h3>
		<p>
		[page:Vector4 target] — el resultado se copiará en este Vector4.<br /><br />

		Devuelve viewport actual.
		</p>

		<h3>[method:Vector2 getDrawingBufferSize]( [param:Vector2 target] )</h3>
		<p>
		[page:Vector2 target] — el resultado se copiará en este Vector2.<br /><br />

		Devuelve el ancho y el alto del renderer's drawing buffer, en píxeles.
		</p>

		<h3>[method:number getPixelRatio]()</h3>
		<p>Devuelve la proporción del píxeles (pixel ratio) del dispositivo actual utilizada.</p>

		<h3>[method:Vector4 getScissor]( [param:Vector4 target] )</h3>
		<p>
		[page:Vector4 target] — el resultado se copiará en este Vector4.<br /><br />

		Devuelve la scissor region.
		</p>

		<h3>[method:Boolean getScissorTest]()</h3>
		<p>Devuelve `true` si la prueba de tijera (scissor test) está habilitada; devuelve `false` de lo contrario.</p>

		<h3>[method:Vector2 getSize]( [param:Vector2 target] )</h3>
		<p>
		[page:Vector2 target] — el resultado se copiará en este Vector2.<br /><br />

		Devuelve el ancho y el alto del canvas de la salida del  renderer, en píxeles.
		</p>

		<h3>[method:Vector4 getViewport]( [param:Vector4 target] )</h3>
		<p>
		[page:Vector4 target] — el resultado se copiará en este Vector4.<br /><br />

		Devuelve el viewport.
		</p>

		<h3>[method:undefined initTexture]( [param:Texture texture] )</h3>
		<p> Inicializa la textura dada. Útil para precargar una textura en lugar de esperar hasta el primer renderizado (lo que puede causar retrasos notables debido a la sobrecarga de decodificación y carga de GPU).</p>

		<h3>[method:undefined resetGLState]( )</h3>
		<p>Restablecer el estado de GL a su valor predeterminado. Se llama internamente si se pierde el contexto WebGL.</p>

		<h3>[method:undefined readRenderTargetPixels]( [param:WebGLRenderTarget renderTarget], [param:Float x], [param:Float y], [param:Float width], [param:Float height], [param:TypedArray buffer], [param:Integer activeCubeFaceIndex] )</h3>
		<p>buffer - Uint8Array es el único tipo de destino admitido en todos los casos, los demás tipos dependen de renderTarget y de la plataforma. Ver [link:https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14.12 WebGL spec] para más detalles.</p>
		<p>
			Lee los datos de píxeles de renderTarget en el búfer que pasa. Esto es un envoltorio sobre [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/readPixels WebGLRenderingContext.readPixels]().</p>
		<p>Ver el ejemplo [example:webgl_interactive_cubes_gpu interactive / cubes / gpu].</p>
		<p>Para leer un [page:WebGLCubeRenderTarget WebGLCubeRenderTarget] use el parámetro opcional activeCubeFaceIndex para determinar qué cara debe leerse.</p>


		<h3>[method:undefined render]( [param:Object3D scene], [param:Camera camera] )</h3>
		<p>
			Renderiza una [page:Scene scene] u otro tipo de [page:Object3D object] usando una [page:Camera camera].<br />

			El renderizado se realiza en un [page:WebGLRenderTarget renderTarget] previamente especificado llamando a [page:WebGLRenderer.setRenderTarget .setRenderTarget] o al canvas como de costumbre.<br />

			De forma predeterminada, los búferes de renderización se borran antes de la renderización, pero puede evitarlo configurando la propiedad [page:WebGLRenderer.autoClear autoClear] en false.
			Si desea evitar que solo se borren ciertos búferes, puede configurar las propiedades [page:WebGLRenderer.autoClearColor autoClearColor], [page:WebGLRenderer.autoClearStencil autoClearStencil] o
			[page:WebGLRenderer.autoClearDepth autoClearDepth] a falso. Para borrar a la fuerza uno o más búferes, llame a [page:WebGLRenderer.clear .clear].
		</p>

		<h3>[method:undefined resetState]()</h3>
		<p>Se puede utilizar para restablecer el estado WebGL interno. Este método es principalmente relevante para aplicaciones que comparten un único contexto WebGL en varias librerías WebGL.</p>

		<h3>[method:undefined setAnimationLoop]( [param:Function callback] )</h3>
		<p>[page:Function callback] — La función se llamará a cada frame disponible. Si se pasa `null`, se detendrá cualquier animación que ya esté en curso.</p>
		<p>Una función integrada que se puede usar en lugar de [link:https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame requestAnimationFrame]. Para proyectos WebXR se debe utilizar esta función.</p>

		<h3>[method:undefined setClearAlpha]( [param:Float alpha] )</h3>
		<p>Establece alpha transparente. La entrada válida es un flotante entre `0.0` y `1.0`.</p>

		<h3>[method:undefined setClearColor]( [param:Color color], [param:Float alpha] )</h3>
		<p>Establece el `clear color` y la opacidad.</p>

		<h3>[method:undefined setPixelRatio]( [param:number value] )</h3>
		<p>
			Establece la proporción de píxeles del dispositivo. Esto generalmente se usa para dispositivos HiDPI para evitar que el canvas de salida se vea borroso.
		</p>

		<h3>[method:undefined setRenderTarget]( [param:WebGLRenderTarget renderTarget], [param:Integer activeCubeFace], [param:Integer activeMipmapLevel] )</h3>
		<p>
		renderTarget - El [page:WebGLRenderTarget renderTarget] que debe activarse. Cuando se proporciona un valor `null`, the canvas se establece como el destino de representación activo en su lugar.<br />
		activeCubeFace - Especifica el lado del cubo activo (PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5) del [page:WebGLCubeRenderTarget]. Al pasar un [page:WebGLArrayRenderTarget] o un [page:WebGL3DRenderTarget] esto indica la capa z en la que se representará (opcional).<br />
		activeMipmapLevel -Especifica el nivel de mipmap activo (opcional).<br /><br />
		Este método establece el objetivo de representación activo.
		</p>

		<h3>[method:undefined setScissor]( [param:Integer x], [param:Integer y], [param:Integer width], [param:Integer height] )<br />
		[method:undefined setScissor]( [param:Vector4 vector] )</h3>

		<p>
			Los parámetros x, y, ancho y alto de la `scissor region`.<br />
			Opcionalmente, un vector de 4 componentes especificando los parámetros de la región.<br /><br />
			
			Establece la `scissor region` de (x, y) a (x + ancho, y + alto).<br />
			(x, y) es la esquina inferior izquierda de la `scissor region`.
		</p>

		<h3>[method:undefined setScissorTest]( [param:Boolean boolean] )</h3>
		<p>
			Activa o desactiva la `scissor test`. Cuando está habilitado, solo los píxeles dentro de la `scissor area` definida se verán afectados por otras acciones del renderizador.
		</p>

		<h3>[method:undefined setOpaqueSort]( [param:Function method] )</h3>
		<p>
			Establece la función de ordenamiento opaca personalizada para WebGLRenderLists. Pase `null` para usar la función pintorSortStable predeterminada.
		</p>

		<h3>[method:undefined setTransparentSort]( [param:Function method] )</h3>
		<p>
			Establece la función de ordenamiento transparente personalizada para WebGLRenderLists. Pase `null` para usar la función reversePainterSortStable predeterminada.
		</p>

		<h3>[method:undefined setSize]( [param:Integer width], [param:Integer height], [param:Boolean updateStyle] )</h3>
		<p>
			Cambia el tamaño del lienzo de salida a (width, height) teniendo en cuenta el  pixel ratio taken into account
			y también configura el viewport to fit that sizepara que se ajuste a ese tamaño, comenzando en (0, 0).
			Establece [page:Boolean updateStyle] en `falso` evita cualquier cambio de estilo en el canvas de salida.
		</p>

		<h3>[method:undefined setViewport]( [param:Integer x], [param:Integer y], [param:Integer width], [param:Integer height] )<br />
		[method:undefined setViewport]( [param:Vector4 vector] )</h3>

		<p>
			Los parámetros x, y, ancho y alto del viewport.<br />
			Opcionalmente, un vector de 4 componentes que especifica los parámetros del viewport.<br /><br />

			Establece viewport para renderizar desde (x, y) a (x + width, y + height).<br />
		(x, y) es la esquina inferior izquierda de la región.
		</p>

		<h2>Fuente</h2>

		<p>
			[link:https://github.com/mrdoob/three.js/blob/master/src/[path].js src/[path].js]
		</p>
	</body>
</html>
